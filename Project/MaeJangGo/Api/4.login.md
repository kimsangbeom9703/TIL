# ë¡œê·¸ì¸ ì •ë¦¬

## modules/auth

### auth.controller.ts
```ts
import {Controller, Post, Body, UseGuards, Req} from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthGuard } from '@nestjs/passport';
@Controller('auth')
export class AuthController {
    constructor(private readonly authService: AuthService) {}

    @Post('login')
    async login(@Body() body: { username: string; password: string }) {
        const user = await this.authService.validateUser(body.username, body.password);
        return this.authService.login(user);
    }
    @Post('refresh')
    async refresh(@Body() body: { refresh_token: string }) {
        console.log("ğŸ”„ Refresh API called", body.refresh_token.substring(0, 20) + "...");
        return this.authService.refresh(body.refresh_token);
    }
    @UseGuards(AuthGuard('jwt'))
    @Post('logout')
    async logout(@Req() req: any) {
        await this.authService.logout(req.user.id);
        return { message: 'ë¡œê·¸ì•„ì›ƒ ì„±ê³µ' };
    }
}

```
### auth.module.ts
```ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';

@Module({
    imports: [
        UsersModule,
        PassportModule,
        ConfigModule,
        JwtModule.registerAsync({
            imports: [ConfigModule],
            inject: [ConfigService],
            useFactory: (cs: ConfigService) => ({
                secret: cs.get<string>('JWT_SECRET'),
                signOptions: { expiresIn: cs.get<string>('JWT_ACCESS_EXPIRES_IN') ?? '15m' },
            }),
        }),
    ],
    providers: [AuthService, JwtStrategy],
    controllers: [AuthController],
    exports: [AuthService],
})
export class AuthModule {}
```
### auth.service.ts
```ts
import {
    Injectable,
    UnauthorizedException,
    ForbiddenException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { verifyPassword } from './password.util';
import * as argon2 from 'argon2';

@Injectable()
export class AuthService {
    constructor(
        private readonly usersService: UsersService,
        private readonly jwtService: JwtService,
    ) {}

    // âœ… ì‚¬ìš©ì ê²€ì¦
    async validateUser(username: string, password: string) {
        const user = await this.usersService.findByUsername(username);
        if (!user) throw new UnauthorizedException('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê³„ì •ì…ë‹ˆë‹¤.');

        // ìë™ ì ê¸ˆ í•´ì œ
        const lockDurationMinutes = parseInt(process.env.LOCK_DURATION_MINUTES ?? '30', 10);
        if (!user.isActive && user.lockedAt) {
            const lockedTime = new Date(user.lockedAt).getTime();
            if (Date.now() - lockedTime >= lockDurationMinutes * 60 * 1000) {
                user.isActive = true;
                user.loginFailCount = 0;
                user.lockedAt = null;
                await this.usersService.save(user);
            }
        }

        if (!user.isActive) {
            throw new ForbiddenException(
                `ê³„ì •ì´ ì ê²¨ ìˆìŠµë‹ˆë‹¤. ${lockDurationMinutes}ë¶„ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.`,
            );
        }

        // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
        const ok = await verifyPassword(user.password, password);
        if (!ok) {
            user.loginFailCount += 1;
            if (user.loginFailCount >= 5) {
                user.isActive = false;
                user.lockedAt = new Date();
            }
            await this.usersService.save(user);
            throw new UnauthorizedException('ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        }

        // ë¡œê·¸ì¸ ì„±ê³µ ì²˜ë¦¬
        user.lastLoginAt = new Date();
        user.loginFailCount = 0;
        user.lockedAt = null;
        await this.usersService.save(user);

        const { password: _, ...result } = user;
        return result;
    }

    // âœ… í† í° ë°œê¸‰ í—¬í¼
    private signTokens(user: { id: number; username: string; role: string }) {
        const payload = { username: user.username, sub: user.id, role: user.role };

        const accessToken = this.jwtService.sign(payload, {
            secret: process.env.JWT_SECRET,
            expiresIn: process.env.JWT_ACCESS_EXPIRES_IN || '15m',
        });

        const refreshToken = this.jwtService.sign(payload, {
            secret: process.env.JWT_SECRET,
            expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
        });

        return { accessToken, refreshToken };
    }

    // âœ… ë¡œê·¸ì¸: AT + RT ë°œê¸‰ & RT í•´ì‹œ ì €ì¥
    async login(user: any) {
        const { accessToken, refreshToken } = this.signTokens(user);

        const rtHash = await argon2.hash(refreshToken, {
            type: argon2.argon2id,
            memoryCost: 2 ** 16,
            timeCost: 3,
            parallelism: 1,
        });
        await this.usersService.setRefreshTokenHash(user.id, rtHash);

        return { access_token: accessToken, refresh_token: refreshToken };
    }

    // âœ… Refresh Token ì¬ë°œê¸‰ (Rotation ë°©ì‹)
    async refresh(refreshToken: string) {
        try {
            const payload = this.jwtService.verify(refreshToken, {
                secret: process.env.JWT_SECRET,
            });

            const user = await this.usersService.findOne(payload.sub);
            if (!user || !user.refreshTokenHash) {
                throw new UnauthorizedException('ë¦¬í”„ë ˆì‹œ í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            // DB í•´ì‹œ ê²€ì¦
            const valid = await argon2.verify(user.refreshTokenHash, refreshToken);
            if (!valid) {
                throw new UnauthorizedException('ë¦¬í”„ë ˆì‹œ í† í°ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            // ìƒˆ í† í° ë°œê¸‰ (Access + Refresh)
            const { accessToken, refreshToken: newRefreshToken } = this.signTokens(user);

            // ìƒˆ RefreshToken í•´ì‹œ ì €ì¥ (Rotation)
            const newRtHash = await argon2.hash(newRefreshToken, {
                type: argon2.argon2id,
                memoryCost: 2 ** 16,
                timeCost: 3,
                parallelism: 1,
            });
            await this.usersService.setRefreshTokenHash(user.id, newRtHash);

            return { access_token: accessToken, refresh_token: newRefreshToken };
        } catch {
            throw new UnauthorizedException('ë¦¬í”„ë ˆì‹œ í† í° ê²€ì¦ ì‹¤íŒ¨');
        }
    }

    // âœ… ë¡œê·¸ì•„ì›ƒ: Refresh Token ì œê±°
    async logout(userId: number) {
        await this.usersService.clearRefreshToken(userId);
    }
}

```
### jwt.strategy.ts
```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
    constructor() {
        super({
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            secretOrKey: process.env.JWT_SECRET || 'secretKey',
            ignoreExpiration: false, // âœ… ë§Œë£Œ ì²´í¬
        });
    }

    async validate(payload: any) {
        return { id: payload.sub, username: payload.username, role: payload.role };
    }
}
```
### password.util.ts
```ts
// src/modules/auth/password.util.ts
import * as argon2 from 'argon2';

export async function hashPassword(password: string): Promise<string> {
    return argon2.hash(password, {
        type: argon2.argon2id, // ê°€ì¥ ê¶Œì¥ë˜ëŠ” ëª¨ë“œ
        memoryCost: 2 ** 16,   // 64MB ì‚¬ìš©
        timeCost: 5,           // ì—°ì‚° íšŸìˆ˜
        parallelism: 1,        // ë³‘ë ¬ ì²˜ë¦¬
    });
}

export async function verifyPassword(hash: string, plain: string): Promise<boolean> {
    return argon2.verify(hash, plain);
}

```
