# 로그인 정리

## modules/auth

### auth.controller.ts
```ts
import {Controller, Post, Body, UseGuards, Req} from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthGuard } from '@nestjs/passport';
@Controller('auth')
export class AuthController {
    constructor(private readonly authService: AuthService) {}

    @Post('login')
    async login(@Body() body: { username: string; password: string }) {
        const user = await this.authService.validateUser(body.username, body.password);
        return this.authService.login(user);
    }
    @Post('refresh')
    async refresh(@Body() body: { refresh_token: string }) {
        console.log("🔄 Refresh API called", body.refresh_token.substring(0, 20) + "...");
        return this.authService.refresh(body.refresh_token);
    }
    @UseGuards(AuthGuard('jwt'))
    @Post('logout')
    async logout(@Req() req: any) {
        await this.authService.logout(req.user.id);
        return { message: '로그아웃 성공' };
    }
}

```
### auth.module.ts
```ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';

@Module({
    imports: [
        UsersModule,
        PassportModule,
        ConfigModule,
        JwtModule.registerAsync({
            imports: [ConfigModule],
            inject: [ConfigService],
            useFactory: (cs: ConfigService) => ({
                secret: cs.get<string>('JWT_SECRET'),
                signOptions: { expiresIn: cs.get<string>('JWT_ACCESS_EXPIRES_IN') ?? '15m' },
            }),
        }),
    ],
    providers: [AuthService, JwtStrategy],
    controllers: [AuthController],
    exports: [AuthService],
})
export class AuthModule {}
```
### auth.service.ts
```ts
import {
    Injectable,
    UnauthorizedException,
    ForbiddenException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { verifyPassword } from './password.util';
import * as argon2 from 'argon2';

@Injectable()
export class AuthService {
    constructor(
        private readonly usersService: UsersService,
        private readonly jwtService: JwtService,
    ) {}

    // ✅ 사용자 검증
    async validateUser(username: string, password: string) {
        const user = await this.usersService.findByUsername(username);
        if (!user) throw new UnauthorizedException('존재하지 않는 계정입니다.');

        // 자동 잠금 해제
        const lockDurationMinutes = parseInt(process.env.LOCK_DURATION_MINUTES ?? '30', 10);
        if (!user.isActive && user.lockedAt) {
            const lockedTime = new Date(user.lockedAt).getTime();
            if (Date.now() - lockedTime >= lockDurationMinutes * 60 * 1000) {
                user.isActive = true;
                user.loginFailCount = 0;
                user.lockedAt = null;
                await this.usersService.save(user);
            }
        }

        if (!user.isActive) {
            throw new ForbiddenException(
                `계정이 잠겨 있습니다. ${lockDurationMinutes}분 후 다시 시도하세요.`,
            );
        }

        // 비밀번호 검증
        const ok = await verifyPassword(user.password, password);
        if (!ok) {
            user.loginFailCount += 1;
            if (user.loginFailCount >= 5) {
                user.isActive = false;
                user.lockedAt = new Date();
            }
            await this.usersService.save(user);
            throw new UnauthorizedException('아이디 또는 비밀번호가 올바르지 않습니다.');
        }

        // 로그인 성공 처리
        user.lastLoginAt = new Date();
        user.loginFailCount = 0;
        user.lockedAt = null;
        await this.usersService.save(user);

        const { password: _, ...result } = user;
        return result;
    }

    // ✅ 토큰 발급 헬퍼
    private signTokens(user: { id: number; username: string; role: string }) {
        const payload = { username: user.username, sub: user.id, role: user.role };

        const accessToken = this.jwtService.sign(payload, {
            secret: process.env.JWT_SECRET,
            expiresIn: process.env.JWT_ACCESS_EXPIRES_IN || '15m',
        });

        const refreshToken = this.jwtService.sign(payload, {
            secret: process.env.JWT_SECRET,
            expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
        });

        return { accessToken, refreshToken };
    }

    // ✅ 로그인: AT + RT 발급 & RT 해시 저장
    async login(user: any) {
        const { accessToken, refreshToken } = this.signTokens(user);

        const rtHash = await argon2.hash(refreshToken, {
            type: argon2.argon2id,
            memoryCost: 2 ** 16,
            timeCost: 3,
            parallelism: 1,
        });
        await this.usersService.setRefreshTokenHash(user.id, rtHash);

        return { access_token: accessToken, refresh_token: refreshToken };
    }

    // ✅ Refresh Token 재발급 (Rotation 방식)
    async refresh(refreshToken: string) {
        try {
            const payload = this.jwtService.verify(refreshToken, {
                secret: process.env.JWT_SECRET,
            });

            const user = await this.usersService.findOne(payload.sub);
            if (!user || !user.refreshTokenHash) {
                throw new UnauthorizedException('리프레시 토큰이 유효하지 않습니다.');
            }

            // DB 해시 검증
            const valid = await argon2.verify(user.refreshTokenHash, refreshToken);
            if (!valid) {
                throw new UnauthorizedException('리프레시 토큰이 일치하지 않습니다.');
            }

            // 새 토큰 발급 (Access + Refresh)
            const { accessToken, refreshToken: newRefreshToken } = this.signTokens(user);

            // 새 RefreshToken 해시 저장 (Rotation)
            const newRtHash = await argon2.hash(newRefreshToken, {
                type: argon2.argon2id,
                memoryCost: 2 ** 16,
                timeCost: 3,
                parallelism: 1,
            });
            await this.usersService.setRefreshTokenHash(user.id, newRtHash);

            return { access_token: accessToken, refresh_token: newRefreshToken };
        } catch {
            throw new UnauthorizedException('리프레시 토큰 검증 실패');
        }
    }

    // ✅ 로그아웃: Refresh Token 제거
    async logout(userId: number) {
        await this.usersService.clearRefreshToken(userId);
    }
}

```
### jwt.strategy.ts
```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
    constructor() {
        super({
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            secretOrKey: process.env.JWT_SECRET || 'secretKey',
            ignoreExpiration: false, // ✅ 만료 체크
        });
    }

    async validate(payload: any) {
        return { id: payload.sub, username: payload.username, role: payload.role };
    }
}
```
### password.util.ts
```ts
// src/modules/auth/password.util.ts
import * as argon2 from 'argon2';

export async function hashPassword(password: string): Promise<string> {
    return argon2.hash(password, {
        type: argon2.argon2id, // 가장 권장되는 모드
        memoryCost: 2 ** 16,   // 64MB 사용
        timeCost: 5,           // 연산 횟수
        parallelism: 1,        // 병렬 처리
    });
}

export async function verifyPassword(hash: string, plain: string): Promise<boolean> {
    return argon2.verify(hash, plain);
}

```
