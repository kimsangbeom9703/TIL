# 권한 및 가드 설정

```
관리자 별 권한을 따로 주기 위해 권한 및 가드를 설정한다.
```

```
 ├── common/           # 공통 유틸/인프라
 │   ├── decorators/
 │   │   └── roles.decorator.ts
 │   │   └── public.decorator.ts
 │   ├── guards/
 │   │   ├── jwt-auth.guard.ts
 │   │   └── roles.guard.ts
 │   ├── filters/
 │   │   └── http-exception.filter.ts
 │   ├── interceptors/
 │   │   └── logging.interceptor.ts
 │   ├── pipes/
 │   └── utils/
 │   │   └── password.util.ts 
```

// common/decorators/roles.decorator.ts
```ts
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export type Role = 'SUPER_ADMIN' | 'ADMIN' | 'MANAGER' | 'USER';

export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);

// 편의 프리셋
export const ADMIN_OR_HIGHER: Role[] = ['ADMIN', 'SUPER_ADMIN'];
export const MANAGER_OR_HIGHER: Role[] = ['MANAGER', 'ADMIN', 'SUPER_ADMIN'];
```

// common/decorators/public.decorator.ts
```ts
import { SetMetadata } from '@nestjs/common';
export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

// common/guards/jwt-auth.guard.ts
```ts
import { ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
    constructor(private reflector: Reflector) {
        super();
    }

    canActivate(context: ExecutionContext) {
        const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (isPublic) {
            return true; // Public 라우트는 인증 검사 안 함
        }
        return super.canActivate(context);
    }
}
```
// common/guards/roles.guard.ts
```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY, Role } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private reflector: Reflector) {}

    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (!requiredRoles) return true;

        const { user } = context.switchToHttp().getRequest();
        return user && requiredRoles.includes(user.role);
    }
}
```
// src/common/utils/password.util.ts
```ts
import * as argon2 from 'argon2';

export async function hashPassword(password: string): Promise<string> {
    return argon2.hash(password, {
        type: argon2.argon2id, // 가장 권장되는 모드
        memoryCost: 2 ** 16,   // 64MB 사용
        timeCost: 5,           // 연산 횟수
        parallelism: 1,        // 병렬 처리
    });
}

export async function verifyPassword(hash: string, plain: string): Promise<boolean> {
    return argon2.verify(hash, plain);
}
```
// app.module.ts
```ts
import {Module} from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import {AppController} from './app.controller';
import {AppService} from './app.service';
import {ConfigModule, ConfigService} from '@nestjs/config';
import {TypeOrmModule, TypeOrmModuleOptions} from '@nestjs/typeorm';
import envConfig from './config/env.config';
import dbConfig from './config/database.config';
import {AuthModule} from './modules/auth/auth.module';
import {UsersModule} from './modules/users/users.module';
import {StoresModule} from './modules/stores/stores.module';
import {JwtAuthGuard} from "./common/guards/jwt-auth.guard";
import {RolesGuard} from "./common/guards/roles.guard";

@Module({
    imports: [
        ConfigModule.forRoot({
            isGlobal: true,              // 전역에서 사용 가능
            load: [envConfig, dbConfig], // DB 설정도 로드
            envFilePath: '.env',         // .env 파일 경로 (기본은 루트)
        }),
        TypeOrmModule.forRootAsync({
            imports: [ConfigModule],
            inject: [ConfigService],
            useFactory: (configService: ConfigService) =>
                configService.get<TypeOrmModuleOptions>('database')!, // ✅ undefined 아님을 보장
        }),
        AuthModule,
        UsersModule,
        StoresModule,
    ],
    controllers: [AppController],
    providers: [
        AppService,
        { provide: APP_GUARD, useClass: JwtAuthGuard },  // 로그인 토큰 먼저 확인
        { provide: APP_GUARD, useClass: RolesGuard },    // Role 검사
    ],
})
export class AppModule {
}
```

## 기존 컨트롤러

```ts
import {Controller, Get, Post, Param, Delete, Body, UseGuards} from '@nestjs/common';
import {UsersService} from './users.service';
import {AuthGuard} from "@nestjs/passport";

@UseGuards(AuthGuard('jwt')) // ✅ 컨트롤러 전체 보호
@Controller('users')
export class UsersController {
    constructor(private readonly usersService: UsersService) {
    }

    @Get()
    findAll() {
        return this.usersService.findAll();
    }

    @Get(':id')
    findOne(@Param('id') id: string) {
        return this.usersService.findOne(Number(id));
    }

    @Post()
    create(@Body() body: { username: string; password: string }) {
        return this.usersService.createUser(body.username, body.password);
    }

    @Delete(':id')
    remove(@Param('id') id: string) {
        return this.usersService.remove(Number(id));
    }
}
```

## 변경 컨트롤러
```ts
// @UseGuards(AuthGuard('jwt'))  제거 app.modules에서 전역으로 관리함.
```

## public 컨트롤러
```ts
import {Controller, Post, Body, Req} from '@nestjs/common';
import {AuthService} from './auth.service';
import {Public} from "../../common/decorators/public.decorator";

@Controller('auth')

export class AuthController {
    constructor(private readonly authService: AuthService) {
    }

    @Post('login')
    @Public()
    async login(@Body() body: { username: string; password: string }) {
        const user = await this.authService.validateUser(body.username, body.password);
        return this.authService.login(user);
    }

    @Post('refresh')
    @Public()
    async refresh(@Body() body: { refresh_token: string }) {
        return this.authService.refresh(body.refresh_token);
    }

    @Post('logout')
    async logout(@Req() req: any) {
        await this.authService.logout(req.user.id);
        return {message: '로그아웃 성공'};
    }
}

//@Public() 통과시켜야할 부분에만 @Public()을 지정
```